<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Registro de Teste - Central de Qualidade</title>
    <!-- Dependências Externas -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Estilos Embutidos -->
    <style>
        :root {
            --primary-color: #3B82F6; --primary-dark: #2563EB;
            --accent-color: #F59E0B; --card-background: #ffffff;
            --text-color: #1F2937; --text-color-light: #4B5563;
            --border-color: #D1D5DB; --focus-shadow-color: rgba(59, 130, 246, 0.25);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            --success-bg: #D1FAE5; --success-border: #10B981; --success-text: #047857;
            --failure-bg: #FEE2E2; --failure-border: #EF4444; --failure-text: #B91C1C;
            --na-bg: #F3F4F6; --na-border: #D1D5DB; --na-text: #4B5563;
            --font-poppins: 'Poppins', sans-serif;
        }
        html, body {
            height: 100%; /* Garante que HTML e BODY ocupem 100% da altura da viewport */
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9;
            display: flex; /* Habilita flexbox para o body */
            flex-direction: column; /* Organiza os filhos em coluna */
            overflow: hidden; /* Impede a rolagem global da página */
        }
        
        /* Estilo da Tela de Login - Moderno e Neutro */
        #mainLoginScreen {
            display: flex; position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #f1f5f9, #e2e8f0);
            justify-content: center; align-items: center; z-index: 9999;
            opacity: 1; transition: opacity 0.5s ease-out;
        }
        #mainLoginScreen.hidden-auth { opacity: 0; pointer-events: none; }
        #mainLoginScreen .login-container {
            background: #ffffff; padding: 40px; border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1); width: 100%; max-width: 420px;
            text-align: center; color: #1f2937;
            transform: translateY(0); opacity: 1; animation: fadeInUpLogin 0.6s ease-out;
            border-top: 5px solid #64748b; /* Slate 500 */
        }
        @keyframes fadeInUpLogin {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        #mainLoginScreen h1 { 
            font-family: var(--font-poppins); margin-bottom: 25px; font-size: 1.8rem; 
            color: #1e293b; /* Slate 800 */
            font-weight: 700; 
        }
        #mainLoginScreen h1 i { margin-right: 12px; color: #64748b; /* Slate 500 */ }

        /* Estilos para o conteúdo principal da aplicação */
        #app-content {
            display: flex; /* Habilita flexbox para o conteúdo do app */
            flex-direction: column; /* Organiza cabeçalho e main em coluna */
            flex-grow: 1; /* Permite que o app-content preencha o espaço vertical restante */
            min-height: 0; /* Essencial para que flex-grow funcione corretamente em alguns navegadores */
            overflow: hidden; /* Esconde a barra de rolagem do próprio app-content */
        }

        #recall-container { 
            flex-grow: 1; /* Faz com que o main preencha o espaço vertical disponível */
            overflow-y: auto; /* Habilita rolagem vertical apenas dentro desta seção se o conteúdo exceder */
            -webkit-overflow-scrolling: touch; /* Melhora a rolagem em dispositivos iOS */
            padding: 1.5rem; /* Ajusta o padding para ser parte da área de rolagem */
            box-sizing: border-box; /* Inclui padding na altura/largura total */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Alinha o conteúdo (o .app) ao topo */
        }
        #recall-container .app { 
            background: var(--card-background); padding: 35px 40px; border-radius: 20px; 
            box-shadow: var(--shadow-lg); width: 100%; max-width: 850px; 
            display: flex; flex-direction: column; gap: 25px; position: relative;
            margin-bottom: 0; /* Remove auto margin que pode interferir com o flexbox */
        }
        #recall-container h1 { text-align: center; font-size: 2rem; font-family: var(--font-poppins); color: var(--primary-dark); margin-bottom: 15px; font-weight: 700; }
        #recall-container .component { 
            padding: 15px 20px; border-radius: 12px; display: flex; flex-direction: column; align-items: stretch;
            user-select: none; transition: all 0.3s ease; border: 1px solid transparent; 
        }
        #recall-container .component-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        #recall-container .component.unmarked-highlight { box-shadow: 0 0 0 3px var(--failure-border); transform: scale(1.01); }
        #recall-container .component:hover { transform: translateY(-2px); box-shadow: 0 4px 8px -2px rgba(0,0,0,0.1); }
        #recall-container .component .icon { font-size: 1.8rem; transition: transform 0.3s ease, color 0.3s ease; }
        #recall-container .status-na { background-color: var(--na-bg); border-color: var(--na-border); color: var(--na-text); }
        #recall-container .status-ok { background-color: var(--success-bg); border-color: var(--success-border); color: var(--success-text); }
        #recall-container .status-falha { background-color: var(--failure-bg); border-color: var(--failure-border); color: var(--failure-text); }
        
        .modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(30, 41, 59, 0.6); 
            display: none; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.35s ease; 
        }
        .modal.visible { display: flex; opacity: 1; visibility: visible; }
        .modal-content { 
            background: #fff; padding: 35px; border-radius: 18px; 
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1); width: 90%; max-width: 550px; 
            transform: translateY(30px) scale(0.95); opacity: 0; transition: transform 0.35s ease, opacity 0.35s ease; 
        }
        .modal.visible .modal-content { transform: translateY(0) scale(1); opacity: 1; }
        .feedback-btn { 
            position: fixed; background: #4B5563; color: white; border: none; border-radius: 50%; width: 60px; height: 60px; 
            font-size: 1.6rem; cursor: pointer; box-shadow: var(--shadow-lg); display: flex; justify-content: center; align-items: center; 
            transition: all 0.3s ease; z-index: 999; bottom: 30px; right: 30px; 
        }
        .feedback-btn:hover { transform: translateY(-5px) scale(1.1); box-shadow: 0 10px 20px rgba(0,0,0,0.2); background: #374151;}

        /* --- Camera and Upload Specific Styles (merged and adapted) --- */
        #cameraContainer {
            display: none; /* Hidden by default */
            max-width: 300px; /* Reduced size on larger screens */
            width: 100%; /* Occupies 100% of available width in its container */
            margin: 15px auto; /* Centered */
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        #cameraPreview {
            width: 100%;
            height: auto; /* Maintains video aspect ratio */
            border: 2px solid #333;
            border-radius: 8px;
            display: block; /* Ensures video occupies full width */
        }
        #captureControls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            padding-bottom: 10px;
        }
        #captureBtn, #cancelCameraBtn { 
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #captureBtn { background-color: #4CAF50; color: white; } /* Green */
        #captureBtn:hover { background-color: #45a049; transform: translateY(-2px); }
        #cancelCameraBtn { background-color: #f44336; color: white; } /* Red */
        #cancelCameraBtn:hover { background-color: #da190b; transform: translateY(-2px); }

        #thumbnails {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
            width: 100%; /* Allows thumbnails to take full available width */
            max-width: 600px; /* Limits width on very large screens */
        }
        .thumbnail {
            position: relative;
            width: 100px; /* Fixed size for thumbnails */
            height: 100px;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            flex-shrink: 0; /* Prevents thumbnail from shrinking */
        }
        .thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 24px;
            text-align: center;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
        .remove-btn:hover { opacity: 1; }
        .no-photos {
            color: #777;
            font-style: italic;
            text-align: center;
            width: 100%;
        }
        #photoLoadingMessage { 
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            width: 80%;
            max-width: 500px;
            word-wrap: break-word;
            text-align: center;
            display: none; /* Hidden by default */
            font-weight: bold;
            color: #2196F3;
        }

        /* Styles for animated confirmation - ADJUSTED FOR BOTTOM-RIGHT */
        #animatedConfirmation {
            position: fixed;
            bottom: 20px; /* Position at the bottom */
            right: 20px; /* Position at the right */
            transform: translateX(0); /* Remove central translation */
            background-color: #4CAF50; /* Green for success */
            color: white;
            padding: 10px 15px; /* Reduced padding */
            border-radius: 8px; /* Slightly smaller border-radius */
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2); /* Adjusted shadow */
            display: flex;
            flex-direction: row; /* Changed to row for horizontal layout */
            align-items: center;
            gap: 10px;
            opacity: 0;
            visibility: hidden; /* Hidden by default, no animation */
            z-index: 1000;
            width: auto; /* Allow width to adjust to content */
            max-width: 90%; /* Prevent it from getting too wide on small screens */
            white-space: nowrap; /* Keep text on single line if possible */
        }

        #animatedConfirmation.is-animating { /* New class to activate animation */
            animation: fade-in-out 3s forwards;
        }

        #animatedConfirmation.error { background-color: #f44336; } /* Red for error */
        #animatedConfirmation.warning { background-color: #ff9800; } /* Orange for warning */

        #animatedConfirmation .icon { 
            font-size: 24px; /* Reduced icon size */
            line-height: 1; /* Align icon better */
        }

        /* Keyframes for animation - ADJUSTED FOR BOTTOM-RIGHT */
        @keyframes fade-in-out {
            0% { opacity: 0; visibility: hidden; transform: translateY(20px); } /* Start slightly below */
            10% { opacity: 1; visibility: visible; transform: translateY(0); } /* Slide up to visible */
            90% { opacity: 1; visibility: visible; transform: translateY(0); } /* Stay visible */
            100% { opacity: 0; visibility: hidden; transform: translateY(20px); } /* Slide down to hidden */
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .main-buttons {
                flex-direction: column;
                align-items: center;
            }
            .main-buttons button {
                width: 80%; /* Buttons occupy more width on small screens */
            }
            #cameraContainer {
                max-width: 90%; /* Camera container occupies more width on small screens */
            }
            .thumbnail {
                width: 80px; /* Slightly smaller thumbnails on very small screens */
                height: 80px;
            }
            #animatedConfirmation {
                bottom: 10px; /* Closer to bottom on small screens */
                right: 10px; /* Closer to right on small screens */
                padding: 8px 12px; /* Even smaller padding */
                font-size: 0.8rem; /* Smaller text */
                white-space: normal; /* Allow text to wrap on small screens */
            }
            #animatedConfirmation .icon {
                font-size: 20px; /* Even smaller icon */
            }
        }
    </style>
</head>
<body>

    <!-- Tela de Login/Identificação (Inicialmente visível) -->
    <div id="mainLoginScreen">
        <div class="login-container">
            <h1><i class="fas fa-user-check"></i>Identificação do Testador</h1>
            <div class="field text-left">
                <label for="mainTesterName" class="font-semibold text-slate-700 mb-1 block">Seu Nome:</label>
                <input type="text" id="mainTesterName" placeholder="Digite seu nome" required autofocus class="block w-full px-4 py-3 bg-slate-50 border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-slate-500 focus:border-slate-500" />
            </div>
            <button type="button" id="mainLoginBtn" class="w-full mt-6 bg-slate-700 text-white font-bold py-3 px-4 rounded-lg hover:bg-slate-800 transition-all duration-300 shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                <i class="fas fa-sign-in-alt mr-2"></i>Entrar
            </button>
            <p id="loginErrorMessage" class="text-red-500 text-sm mt-4 h-4"></p>
        </div>
    </div>

    <!-- Conteúdo da Aplicação (Inicialmente oculto) -->
    <div id="app-content" class="hidden">
        <header class="bg-white/80 backdrop-blur-sm shadow-sm w-full z-20 flex-shrink-0 sticky top-0">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3 flex flex-col sm:flex-row justify-between items-center">
                <div class="flex items-center gap-3 mb-2 sm:mb-0">
                    <i class="fas fa-clipboard-list text-2xl text-amber-500"></i>
                    <h1 class="text-xl md:text-2xl font-bold text-slate-800 font-poppins text-center sm:text-left">Registrar Novo Teste</h1>
                </div>
                
                <div class="flex items-center gap-4 flex-wrap justify-center sm:justify-end w-full sm:w-auto">
                    <div id="testerNameDisplay" class="text-sm text-slate-600 flex items-center gap-2">
                        <i class="fas fa-user-circle text-slate-500"></i>
                        <span>Testador:</span>
                        <span id="testerNameText" class="font-semibold"></span>
                        <!-- Span para exibir o ID do teste ao lado do nome do testador -->
                        <span id="testIdDisplay" class="text-slate-500 text-sm font-normal ml-2"></span>
                        <button id="logoutBtn" title="Trocar Testador" class="ml-2 text-slate-500 hover:text-red-500 transition-colors duration-200 focus:outline-none">
                            <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                    <!-- Button style and text updated -->
                    <button id="backToMenuBtn" class="text-sm bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-3 rounded-md transition-colors duration-200 flex items-center gap-2 mt-2 sm:mt-0">
                        <i class="fas fa-arrow-left fa-sm"></i>
                        Voltar ao Menu
                    </button>
                </div>
            </div>
        </header>

        <main id="recall-container" class="flex-grow flex items-start justify-center p-4 sm:p-6 lg:p-8">
            <div class="app">
                <h1 class="mt-4"><i class="fas fa-edit" style="margin-right:10px;"></i>Formulário de Teste</h1>
                <form id="dataForm">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="field"><label for="modelo" class="font-semibold">Modelo do Dispositivo</label><select id="modelo" name="modelo" required class="mt-1 block w-full px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"><option value="" disabled selected>Selecione o modelo</option><option value="HF801">HF801</option><option value="HF810">HF810</option><option value="HF900">HF900</option><option value="HF405">HF405</option><option value="HF918">HF918</option></select></div>
                        <div class="field hidden" id="clienteField">
                            <!-- MODIFIED: Added lock button -->
                            <div class="flex items-center justify-between mb-1">
                                <label for="cliente" class="font-semibold">Nome do Cliente</label>
                                <button type="button" id="lockClientBtn" class="text-slate-500 hover:text-blue-500 transition-colors duration-200" title="Manter nome do cliente após o envio">
                                    <i class="fas fa-lock-open" id="lockIcon"></i>
                                </button>
                            </div>
                            <input type="text" id="cliente" name="cliente" placeholder="Ex: João Silva" required class="mt-1 block w-full px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"/>
                        </div>
                    </div>
                    <fieldset class="hidden" id="componentesField"><legend class="font-semibold text-lg text-slate-700 mt-6 mb-4 border-b pb-2">Status dos Componentes</legend><div id="components" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div></fieldset>
                    <button type="submit" class="hidden w-full mt-8 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition-all duration-300 shadow-lg hover:shadow-xl transform hover:-translate-y-1" id="enviarBtn">
                        <i class="fas fa-paper-plane" style="margin-right: 8px;"></i>Enviar Teste
                    </button>
                </form>
                <div id="status" aria-live="polite" class="text-center mt-4"></div>
            </div>
            <button class="feedback-btn" id="feedbackBtn" title="Enviar Feedback"> <i class="fas fa-bullhorn"></i> </button>
        </main>
    </div>
    
    <!-- Modais -->
    <div class="modal" id="confirmSendModal">
        <div class="modal-content">
            <h2 class="text-xl font-bold font-poppins text-slate-800"><i class="fas fa-question-circle text-blue-500 mr-2"></i>Confirmar Envio?</h2>
            <p class="text-slate-600">Revise os dados se necessário. Deseja prosseguir?</p>
            
            <div class="field mt-4">
                <label for="observacao" class="font-semibold">Observação Geral (opcional)</label>
                <textarea id="observacao" placeholder="Adicione qualquer observação relevante..." class="mt-1 block w-full px-3 py-2 bg-slate-50 border border-slate-300 rounded-md"></textarea>
            </div>

            <!-- Camera/Photo Upload Section -->
            <h3 class="text-lg font-semibold text-slate-700 mt-6 mb-2">Anexar Fotos:</h3>
            <div class="flex flex-wrap gap-3 justify-center">
                <button type="button" id="openCameraButton" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors duration-200 shadow-md">
                    <i class="fas fa-camera mr-2"></i>Abrir Câmera
                </button>
            </div>

            <!-- Camera Container -->
            <div id="cameraContainer" class="hidden my-4 max-w-sm mx-auto rounded-lg shadow-lg overflow-hidden border-2 border-gray-300">
                <video id="cameraPreview" class="w-full h-auto block rounded-t-lg" playsinline></video>
                <div id="captureControls" class="flex justify-center gap-3 p-3 bg-gray-100 rounded-b-lg">
                    <button id="captureBtn" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors duration-200">Tirar Foto</button>
                    <button id="cancelCameraBtn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition-colors duration-200">Cancelar</button>
                </div>
            </div>

            <!-- Thumbnails Area -->
            <h3 class="text-base font-semibold text-slate-700 mt-4">Fotos selecionadas:</h3>
            <div id="thumbnails" class="flex flex-wrap gap-3 justify-center mt-2 p-2 bg-white rounded-md border border-gray-200 min-h-[100px] items-center">
                <span class="no-photos text-slate-500 italic">Nenhuma foto selecionada ainda</span>
            </div>

            <!-- Loading Message for Photo Upload -->
            <div id="photoLoadingMessage" class="hidden mt-4 p-3 bg-blue-100 text-blue-800 rounded-lg text-center font-semibold">Enviando fotos... Por favor, aguarde.</div>

            <div class="flex justify-end gap-4 mt-6">
                <button type="button" class="bg-slate-200 px-4 py-2 rounded-lg text-slate-700 hover:bg-slate-300 transition-colors" id="cancelSend">Cancelar</button>
                <button type="button" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors" id="confirmSend">Confirmar</button>
            </div>
        </div>
    </div>

    <div class="modal" id="feedbackModal">
        <div class="modal-content">
            <h2 class="text-xl font-bold font-poppins text-slate-800"><i class="fas fa-bullhorn text-amber-500 mr-2"></i>Enviar Feedback</h2>
            <p class="text-slate-600">Compartilhe suas sugestões, bugs ou melhorias.</p>
            <div class="field mt-4"><label for="feedbackType" class="font-semibold">Tipo</label><select id="feedbackType" class="mt-1 block w-full px-3 py-2 bg-white border border-slate-300 rounded-md"><option value="bug">Bug / Erro</option><option value="melhoria">Sugestão de Melhoria</option><option value="outros">Outros</option></select></div>
            <div class="field mt-2"><label for="feedbackDescription" class="font-semibold">Descrição</label><textarea id="feedbackDescription" placeholder="Descreva em detalhes..." class="mt-1 block w-full px-3 py-2 bg-slate-50 border border-slate-300 rounded-md"></textarea></div>
            <div id="feedbackStatus" aria-live="polite"></div>
            <div class="flex justify-end gap-4 mt-4"><button type="button" class="bg-slate-200 px-4 py-2 rounded-lg" id="cancelFeedback">Cancelar</button><button type="button" class="bg-amber-500 text-white px-4 py-2 rounded-lg" id="submitFeedbackBtn">Enviar</button></div>
        </div>
    </div>

    <!-- NEW MODAL for N/A confirmation -->
    <div class="modal" id="naConfirmationModal">
        <div class="modal-content">
            <h2 class="text-xl font-bold font-poppins text-red-500"><i class="fas fa-exclamation-triangle mr-2"></i>Atenção!</h2>
            <p class="text-slate-600">Você tem certeza que deseja enviar o teste com componentes **não avaliados (N/A)**?</p>
            <div class="flex justify-end gap-4 mt-4">
                <button type="button" class="bg-slate-200 px-4 py-2 rounded-lg text-slate-700 hover:bg-slate-300 transition-colors" id="cancelNaSend">Cancelar</button>
                <button type="button" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition-colors" id="confirmNaSend">Enviar Assim Mesmo</button>
            </div>
        </div>
    </div>


    <!-- Animated Confirmation (outside modals, fixed position) -->
    <div id="animatedConfirmation">
        <span class="icon"></span>
        <p class="message"></p>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- ESTADO E CONFIGURAÇÃO ---
        let globalTesterName = '';
        let recallAppInitialized = false;
        let currentTestId = null; // Variável para armazenar o ID único do teste atual
        let longPressTimer = null; // Timer para a detecção de long press
        const LONG_PRESS_THRESHOLD = 500; // Milissegundos para considerar um long press (0.5 segundos)

        // Variáveis para o bloqueio do cliente
        let isClientLocked = false;
        let lockedClientName = '';

        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbyE4h4LL3vk8n0m2A0C3p3n6Plz9w9YV0Ip_N8CpBpIk9VRKQmSkIWmzDL05XgdVKmlmw/exec';
        // URL para o Google Apps Script de upload de fotos. Certifique-se de que este script esteja ativo e configurado corretamente.
        const PHOTO_UPLOAD_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbyon32vtTfnuG0DcdLiRJb5TK9fPzVHcOnULufkyV9lEWNIFBhz-oyAgCNjY6gBtoJf/exec";

        const componentesConfig = [ 
            { id: 'aht10', label: 'AHT10' }, { id: 'botao_esquerdo', label: 'Botão Esquerdo' }, { id: 'botao_central', label: 'Botão Central' }, 
            { id: 'botao_direito', label: 'Botão Direito' }, { id: 'botao_reset', label: 'Botão Reset' }, { id: 'certificado', label: 'Certificado' }, 
            { id: 'conector_mola', label: 'Conector Mola' }, { id: 'esp32', label: 'ESP32' }, { id: 'display', label: 'Display' }, { id: 'led_azul', label: 'LED Azul' }, 
            { id: 'ledrgb', label: 'LED RGB' }, { id: 'ldr', label: 'LDR' }, { id: 'ntc', label: 'NTC' }, { id: 'relay', label: 'Relay' }, { id: 'tm1637', label: 'TM1637' }, 
            { id: 'watchdog', label: 'Watchdog' }, { id: 'serigrafia', label: 'Serigrafia' } 
        ];
        const STATUS_NA = 'N/A', STATUS_OK = 'OK', STATUS_FALHA = 'FALHA';
        const statusCycle = [STATUS_NA, STATUS_OK, STATUS_FALHA];
        const statusInfo = {
            [STATUS_NA]: { icon: 'fas fa-minus-circle', class: 'status-na' },
            [STATUS_OK]: { icon: 'fas fa-check-circle', class: 'status-ok' },
            [STATUS_FALHA]: { icon: 'fas fa-times-circle', class: 'status-falha' }
        };
        const hideMap = { 
            'HF801': ['aht10', 'botao_central'], 
            'HF810': ['aht10', 'botao_central'], 
            'HF900': ['aht10', 'botao_central'], 
            'HF405': ['aht10', 'ntc', 'botao_central'], 
            'HF918': ['ntc', 'tm1637'] 
        };
        let estadoComponentes = {}, componentesParaExibir = [];

        // --- Variáveis Globais da Câmera e Upload ---
        let cameraStream = null; 
        let filesToUpload = [];

        // --- SELEÇÃO DE ELEMENTOS DOM ---
        const mainLoginScreen = document.getElementById('mainLoginScreen'), mainTesterNameInput = document.getElementById('mainTesterName'), mainLoginBtn = document.getElementById('mainLoginBtn'), loginErrorMessage = document.getElementById('loginErrorMessage');
        const appContent = document.getElementById('app-content'), testerNameText = document.getElementById('testerNameText'), backToMenuBtn = document.getElementById('backToMenuBtn'), logoutBtn = document.getElementById('logoutBtn');
        const form = document.getElementById('dataForm'), modeloSelect = document.getElementById('modelo'), clienteField = document.getElementById('clienteField'), clienteInput = document.getElementById('cliente'), componentesField = document.getElementById('componentesField'), componentsDiv = document.getElementById('components'), enviarBtn = document.getElementById('enviarBtn'), statusDiv = document.getElementById('status');
        const confirmSendModal = document.getElementById('confirmSendModal'), observacaoTextarea = document.getElementById('observacao'), confirmSendBtn = document.getElementById('confirmSend'), cancelSendBtn = document.getElementById('cancelSend');
        const feedbackModal = document.getElementById('feedbackModal'), feedbackBtn = document.getElementById('feedbackBtn'), feedbackTypeSelect = document.getElementById('feedbackType'), feedbackDescriptionTextarea = document.getElementById('feedbackDescription'), submitFeedbackBtn = document.getElementById('submitFeedbackBtn'), cancelFeedbackBtn = document.getElementById('cancelFeedback'), feedbackStatusDiv = document.getElementById('feedbackStatus');

        // Elementos DOM da Câmera e Upload
        const openCameraButton = document.getElementById('openCameraButton');
        const cameraContainer = document.getElementById('cameraContainer');
        const cameraPreview = document.getElementById('cameraPreview');
        const captureBtn = document.getElementById('captureBtn');
        const cancelCameraBtn = document.getElementById('cancelCameraBtn'); 
        const thumbnailsContainer = document.getElementById('thumbnails');
        const photoLoadingMessageDiv = document.getElementById('photoLoadingMessage'); 
        const animatedConfirmationDiv = document.getElementById('animatedConfirmation');
        // testIdDisplay agora está no header ao lado do nome do testador
        const testIdDisplay = document.getElementById('testIdDisplay'); 

        // Elementos do modal de confirmação de N/A
        const naConfirmationModal = document.getElementById('naConfirmationModal');
        const confirmNaSendBtn = document.getElementById('confirmNaSend');
        const cancelNaSendBtn = document.getElementById('cancelNaSend');

        // Elementos para o bloqueio do cliente
        const lockClientBtn = document.getElementById('lockClientBtn');
        const lockIcon = document.getElementById('lockIcon');


        // --- LÓGICA DE PERSISTÊNCIA E INICIALIZAÇÃO ---
        function checkLoginStatus() {
            const savedName = localStorage.getItem('testerName');
            const savedIsClientLocked = localStorage.getItem('isClientLocked');
            
            if (savedIsClientLocked === 'true') {
                isClientLocked = true;
                lockedClientName = localStorage.getItem('lockedClientName') || '';
            } else {
                isClientLocked = false;
                lockedClientName = '';
            }

            if (savedName) {
                globalTesterName = savedName;
                showApp();
            } else {
                showLogin();
            }
        }
        
        function showLogin() { 
            mainLoginScreen.classList.remove('hidden-auth'); 
            appContent.classList.add('hidden'); 
            mainTesterNameInput.focus(); 
            mainTesterNameInput.value = '';
        }
        function showApp() { 
            mainLoginScreen.classList.add('hidden-auth'); 
            appContent.classList.remove('hidden'); 
            if (!recallAppInitialized) initRecallApp(); 
            testerNameText.textContent = globalTesterName; 
            // Garante que o ID do teste seja limpo ao mostrar o app, ou gere um novo se necessário
            currentTestId = null; // Limpa o ID antigo ao entrar no app
            testIdDisplay.textContent = ''; // Garante que não haja ID pré-existente
            
            // Define o estado inicial do campo do cliente e do botão de cadeado
            if (isClientLocked) {
                clienteInput.value = lockedClientName;
                lockIcon.className = 'fas fa-lock'; // Define o ícone como cadeado fechado
                clienteField.classList.remove('hidden'); // Garante que o campo do cliente esteja visível
            } else {
                lockIcon.className = 'fas fa-lock-open'; // Define o ícone como cadeado aberto
                clienteInput.value = ''; // Garante que esteja limpo se não estiver bloqueado
            }
        }
        
        function handleLogin() {
            const name = mainTesterNameInput.value.trim();
            if (name.length < 3) { loginErrorMessage.textContent = 'Por favor, digite um nome válido.'; return; }
            loginErrorMessage.textContent = '';
            localStorage.setItem('testerName', name);
            globalTesterName = name;
            showApp();
        }

        function handleLogout() {
            localStorage.removeItem('testerName');
            globalTesterName = '';
            // Ao deslogar, redefinir também o estado do bloqueio do cliente e o nome salvo
            isClientLocked = false;
            lockedClientName = '';
            localStorage.removeItem('isClientLocked');
            localStorage.removeItem('lockedClientName');
            if(recallAppInitialized) {
                resetForm();
            }
            showLogin();
        }
        
        // --- LÓGICA DO APP DE REGISTRO ---
        function initRecallApp() {
            if (recallAppInitialized) return;
            recallAppInitialized = true;

            // --- Event Listeners do App ---
            modeloSelect.addEventListener('change', () => {
                const modelo = modeloSelect.value;
                // Apenas limpa o campo cliente se NÃO estiver bloqueado
                if (!isClientLocked) {
                    clienteInput.value = ''; 
                }
                testIdDisplay.textContent = ''; // Limpa o ID antigo
                currentTestId = null; // Zera o ID ao mudar o modelo
                if (modelo) {
                    clienteField.classList.remove('hidden');
                    componentesField.classList.remove('hidden');
                    enviarBtn.classList.remove('hidden');
                    if (!isClientLocked) { // Apenas foca se precisar de uma nova entrada
                        clienteInput.focus();
                    }
                    generateAndDisplayTestId(); // Gera e exibe o ID quando o modelo é selecionado
                } else {
                    // Se nenhum modelo for selecionado, reseta o formulário completamente (o que respeitará o bloqueio do cliente)
                    resetForm();
                }
                clearStatusMessage(statusDiv);
                gerarComponentesUI(modelo);
            });

            // O ID será gerado apenas na mudança do modelo, não mais no input do cliente.
            clienteInput.addEventListener('input', () => {
                // Não é mais necessário gerar ID aqui, mas pode-se validar a presença do ID
                if (!currentTestId && modeloSelect.value.trim() && clienteInput.value.trim()) {
                    generateAndDisplayTestId();
                } else if (!clienteInput.value.trim() && modeloSelect.value.trim()) {
                    // Se o nome do cliente for apagado, mas o modelo ainda está selecionado
                    // podemos manter o ID, ou limpá-lo se a intenção for iniciar um novo teste.
                    // Por enquanto, vamos mantê-lo, pois já está vinculado ao modelo.
                }
            });

            // Listener para o botão de cadeado do cliente
            lockClientBtn.addEventListener('click', () => {
                isClientLocked = !isClientLocked;
                localStorage.setItem('isClientLocked', isClientLocked);
                if (isClientLocked) {
                    lockIcon.className = 'fas fa-lock'; // Troca para cadeado fechado
                    lockedClientName = clienteInput.value.trim(); // Salva o nome atual do cliente
                    localStorage.setItem('lockedClientName', lockedClientName);
                    showAnimatedConfirmation('Nome do cliente fixado.', 'success');
                } else {
                    lockIcon.className = 'fas fa-lock-open'; // Troca para cadeado aberto
                    lockedClientName = ''; // Limpa o nome salvo
                    localStorage.removeItem('lockedClientName');
                    showAnimatedConfirmation('Nome do cliente não será mais fixado.', 'warning');
                }
            });


            form.addEventListener('submit', (e) => {
                e.preventDefault(); clearStatusMessage(statusDiv);
                if (!modeloSelect.value) { showAnimatedConfirmation('Selecione um modelo.', 'error'); return; }
                if (!clienteInput.value.trim()) { showAnimatedConfirmation('Informe o nome do cliente.', 'error'); return; }
                
                // Garante que o ID foi gerado antes de prosseguir
                if (!currentTestId) { 
                    generateAndDisplayTestId(); 
                    showAnimatedConfirmation('ID do teste gerado. Por favor, tente enviar novamente.', 'warning');
                    return; // Retorna para que o usuário possa rever
                }

                const unmarked = componentesParaExibir.find(comp => estadoComponentes[comp.id]?.status === STATUS_NA);
                if (unmarked) {
                    // Se houver componentes N/A, mostra o novo modal de confirmação de N/A
                    naConfirmationModal.classList.add('visible');
                    // Não prossegue para confirmSendModal ainda, espera a decisão do usuário no naConfirmationModal
                } else {
                    // Se não houver componentes N/A, prossegue para o modal de confirmação principal
                    confirmSendModal.classList.add('visible');
                }
            });
            
            // Listeners dos Modais
            confirmSendBtn.addEventListener('click', () => { confirmSendModal.classList.remove('visible'); submitData(); });
            cancelSendBtn.addEventListener('click', () => confirmSendModal.classList.remove('visible'));
            
            // Listeners para o modal de confirmação de N/A
            confirmNaSendBtn.addEventListener('click', () => {
                naConfirmationModal.classList.remove('visible'); // Esconde o modal de N/A
                confirmSendModal.classList.add('visible');     // Mostra o modal de confirmação principal
            });
            cancelNaSendBtn.addEventListener('click', () => {
                naConfirmationModal.classList.remove('visible'); // Esconde o modal de N/A
                // O usuário optou por não enviar com N/A, então não faz mais nada.
            });

            // REFACTOR: Unificação do manuseio de eventos de clique/toque para o feedbackBtn
            let touchMoved = false; // Flag para detectar arrasto em touch
            
            feedbackBtn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Evita rolagem e zoom ao tocar
                touchMoved = false; // Reseta o flag de movimento
                touchStartTime = new Date().getTime();
                longPressTimer = setTimeout(() => {
                    setAllComponentsToOK();
                    longPressTimer = null; // Limpa o timer pois a ação de long press foi executada
                }, LONG_PRESS_THRESHOLD);
            }, { passive: false });

            feedbackBtn.addEventListener('touchmove', () => {
                touchMoved = true; // Define que houve movimento durante o toque
            });

            feedbackBtn.addEventListener('touchend', (e) => {
                e.preventDefault(); // Evita o comportamento padrão do touch
                clearTimeout(longPressTimer); // Sempre limpa o timer ao levantar o dedo
                longPressTimer = null; // Garante que o timer seja null

                // Se não houve movimento (um toque puro) E o long press não foi detectado (timer foi limpo antes de disparar)
                if (!touchMoved && !longPressTimer) { // longPressTimer já é null aqui se o timeout NÃO disparou
                     feedbackModal.classList.add('visible');
                }
            }, { passive: false });

            // Para eventos de mouse (garantir que funcionem em desktop)
            let mouseDownTime;
            let mouseLongPressFired = false;

            feedbackBtn.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Botão esquerdo do mouse
                    mouseLongPressFired = false; // Reseta o flag
                    mouseDownTime = new Date().getTime();
                    longPressTimer = setTimeout(() => {
                        setAllComponentsToOK();
                        mouseLongPressFired = true; // Marca que o long press foi disparado
                        longPressTimer = null;
                    }, LONG_PRESS_THRESHOLD);
                }
            });

            feedbackBtn.addEventListener('mouseup', () => {
                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (!mouseLongPressFired) { // Se o long press NÃO foi disparado (foi um clique rápido)
                    feedbackModal.classList.add('visible');
                }
            });

            feedbackBtn.addEventListener('mouseleave', () => {
                clearTimeout(longPressTimer);
                longPressTimer = null;
                mouseLongPressFired = false; // Reseta o flag se o mouse sair do botão
            });

            // O event listener 'click' padrão é removido ou ignorado para evitar duplicação,
            // pois 'touchend' e 'mouseup' já tratam o toque/clique rápido.

            cancelFeedbackBtn.addEventListener('click', () => feedbackModal.classList.remove('visible'));
            submitFeedbackBtn.addEventListener('click', submitFeedback);

            // Listeners da Câmera/Upload
            openCameraButton.addEventListener('click', () => openCamera('environment'));
            captureBtn.addEventListener('click', capturePhoto);
            cancelCameraBtn.addEventListener('click', closeCamera);
        }

        /**
         * Gera um ID único para o teste no formato (Letra + 4 Dígitos) e o exibe.
         * Note: Esta geração de ID é client-side e não verifica duplicidade em tempo real na planilha.
         * Para uma garantia de unicidade robusta, seria necessária uma verificação no Google Apps Script antes do envio dos dados.
         */
        function generateAndDisplayTestId() {
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            const randomLetter = letters.charAt(Math.floor(Math.random() * letters.length));
            const randomDigits = Math.floor(1000 + Math.random() * 9000); // Gera um número de 4 dígitos
            currentTestId = `(${randomLetter}${randomDigits})`;
            testIdDisplay.textContent = currentTestId; // Exibe no elemento testIdDisplay no header
            console.log("ID do Teste gerado:", currentTestId);
        }

        /**
         * Sets the status of all visible components to 'OK'.
         */
        function setAllComponentsToOK() {
            console.log("Long press detectado: Definindo todos os componentes como OK.");
            document.querySelectorAll('.component').forEach(componentDiv => {
                const componentId = componentDiv.dataset.componentId;
                // Only change if the component is actually part of the displayed components
                if (componentesParaExibir.some(c => c.id === componentId)) {
                    // Update state
                    estadoComponentes[componentId].status = STATUS_OK;
                    estadoComponentes[componentId].obs = ''; // Clear any observations if setting to OK

                    // Update UI
                    componentDiv.className = `component ${statusInfo[STATUS_OK].class}`;
                    componentDiv.querySelector('.icon').className = `icon ${statusInfo[STATUS_OK].icon}`;
                    componentDiv.querySelector('.failure-details').classList.add('hidden'); // Hide details
                    componentDiv.querySelector('textarea').value = ''; // Clear textarea content
                }
            });
            showAnimatedConfirmation("Todos os componentes marcados como OK!", 'success');
        }


        function resetForm() {
            let tempClientName = '';
            if (isClientLocked) {
                tempClientName = clienteInput.value.trim(); // Salva o nome do cliente antes do reset completo
            }

            form.reset();
            componentsDiv.innerHTML = '';
            clienteField.classList.add('hidden');
            componentesField.classList.add('hidden');
            enviarBtn.classList.add('hidden');
            estadoComponentes = {};
            componentesParaExibir = [];
            clearStatusMessage(statusDiv);
            // Redefine estados relacionados à foto e ID
            filesToUpload = [];
            updateThumbnails(); // Limpa as miniaturas
            closeCamera(); // Garante que a câmera esteja desligada
            currentTestId = null;
            testIdDisplay.textContent = ''; // Limpa a exibição do ID no header

            if (isClientLocked) {
                clienteInput.value = tempClientName; // Restaura o nome do cliente
                clienteField.classList.remove('hidden'); // Garante que o campo do cliente esteja visível
            }
        }

        function showStatusMessage(element, message, type = 'success') {
            element.textContent = message;
            element.className = 'text-center my-2 p-2 rounded-md text-sm';
            if (type === 'success') {
                element.classList.add('bg-green-100', 'text-green-800');
            } else {
                element.classList.add('bg-red-100', 'text-red-800');
            }
        }
        function clearStatusMessage(element) { element.textContent = ''; element.className = 'text-center my-2'; }

        function gerarComponentesUI(modelo) {
            componentsDiv.innerHTML = ''; 
            estadoComponentes = {};
            if (!modelo) return;

            const hideList = hideMap[modelo] || [];
            
            componentesParaExibir = componentesConfig.filter(comp => {
                if (modelo === 'HF918' && comp.id === 'botao_central') {
                    return true; 
                }
                return !hideList.includes(comp.id);
            });

            componentesParaExibir.forEach(comp => {
                estadoComponentes[comp.id] = { status: STATUS_NA, obs: '' };
                const div = document.createElement('div');
                div.className = `component ${statusInfo[STATUS_NA].class}`;
                div.dataset.componentId = comp.id;
                
                div.innerHTML = `
                    <div class="component-header" tabindex="0">
                        <span class="font-semibold">${comp.label}</span>
                        <i class="icon ${statusInfo[STATUS_NA].icon}"></i>
                    </div>
                    <div class="failure-details hidden mt-2">
                        <textarea class="w-full p-2 border rounded-md bg-white" placeholder="Detalhe a falha..."></textarea>
                    </div>
                `;
                
                div.querySelector('.component-header').addEventListener('click', () => changeStatus(div, comp.id));
                div.querySelector('.component-header').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        changeStatus(div, comp.id);
                    }
                });
                
                const textarea = div.querySelector('textarea');
                textarea.addEventListener('input', (e) => {
                    estadoComponentes[comp.id].obs = e.target.value;
                });
                textarea.addEventListener('click', e => e.stopPropagation());
                textarea.addEventListener('keypress', e => e.stopPropagation());
                componentsDiv.appendChild(div);
            });
        }

        function changeStatus(element, componentId) {
            const currentStatus = estadoComponentes[componentId].status;
            const nextIndex = (statusCycle.indexOf(currentStatus) + 1) % statusCycle.length;
            const newStatus = statusCycle[nextIndex];
            estadoComponentes[componentId].status = newStatus;

            element.className = `component ${statusInfo[newStatus].class}`;
            element.querySelector('.icon').className = `icon ${statusInfo[newStatus].icon}`;
            
            const detailsDiv = element.querySelector('.failure-details');
            detailsDiv.classList.toggle('hidden', newStatus !== STATUS_FALHA);
        }
        
        function getTestColor() {
            const statuses = componentesParaExibir.map(c => estadoComponentes[c.id].status);
            
            if (statuses.includes(STATUS_FALHA)) {
                return '#FEE2E2'; // Vermelho (Falha)
            }
            if (statuses.every(s => s === STATUS_OK)) {
                return '#A7F3D0'; // Verde (Tudo OK)
            }
             if (statuses.some(s => s === STATUS_OK)) {
                return '#FDE68A'; // Amarelo (OK e N/A)
            }
            return '#F3F4F6'; // Cinza (Neutra, caso só tenha N/A)
        }


        async function submitData() {
            enviarBtn.disabled = true;
            enviarBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Enviando...';
            
            const testColor = getTestColor();
            let photoUploadSuccess = true; // Assume sucesso inicialmente
            let combinedMessage = 'Dados enviados com sucesso!';
            let combinedMessageType = 'success';

            // 1. Enviar fotos primeiro
            if (filesToUpload.length > 0) {
                console.log("Chamando uploadPhotos() antes de enviar dados do formulário.");
                const uploadResult = await uploadPhotos(); // Chamar a função de upload e obter o resultado
                if (!uploadResult) { // Se o upload de fotos falhou
                    photoUploadSuccess = false;
                    combinedMessage = 'Dados do formulário enviados, mas houve falha no upload de ALGUMAS fotos.';
                    combinedMessageType = 'warning'; // Define como aviso, já que os dados podem ter ido
                } else {
                    combinedMessage = 'Dados e fotos enviados com sucesso!';
                }
            } else {
                console.log("Nenhuma foto para enviar.");
            }

            // 2. Prepara o payload do formulário principal
            const payload = {
                action: 'create',
                data: new Date().toISOString(),
                modelo: modeloSelect.value,
                cliente: clienteInput.value.trim(), // Cliente SEM o ID prefixado na planilha
                nome_tester: `${globalTesterName} ${currentTestId}`, // Testador COM o ID prefixado na planilha
                tester_color: testColor,
                observacao: observacaoTextarea.value.trim(),
                test_id: currentTestId // Mantém o ID separado se precisar no script da planilha para outros fins
            };

            componentesConfig.forEach(comp => {
                if (componentesParaExibir.some(c => c.id === comp.id)) {
                    const state = estadoComponentes[comp.id];
                    payload[comp.id] = state.status === STATUS_FALHA && state.obs.trim() ? `${STATUS_FALHA} (${state.obs.trim()})` : state.status;
                } else {
                    payload[comp.id] = '-';
                }
            });

            // 3. Enviar dados do formulário
            try {
                await fetch(SCRIPT_URL, { method: 'POST', mode: 'no-cors', body: JSON.stringify(payload) });
            }
            // Use o mesmo immersive id as in the context
            catch (err) {
                console.error("Erro no envio de dados do formulário:", err);
                combinedMessage = 'Erro crítico ao enviar dados do formulário. Verifique sua conexão. (Fotos: ' + (photoUploadSuccess ? 'Sucesso' : 'Falha') + ')';
                combinedMessageType = 'error';
            } finally {
                // Exibe a confirmação animada final com base no resultado combinado
                showAnimatedConfirmation(combinedMessage, combinedMessageType);
                enviarBtn.disabled = false;
                enviarBtn.innerHTML = '<i class="fas fa-paper-plane mr-2"></i>Enviar Teste';
                setTimeout(() => resetForm(), 2000); // Reseta o formulário após 2 segundos
            }
        }
        
        async function submitFeedback() {
            const type = feedbackTypeSelect.value;
            const description = feedbackDescriptionTextarea.value.trim();
            if (!description) { showAnimatedConfirmation('Por favor, descreva seu feedback.', 'error'); return; }

            submitFeedbackBtn.disabled = true;
            submitFeedbackBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Enviando...';
            
            try {
                const payload = { action: 'submitFeedback', timestamp: new Date().toISOString(), nome_tester: globalTesterName, tipo: type, descricao: description };
                await fetch(SCRIPT_URL, { method: 'POST', mode: 'no-cors', body: JSON.stringify(payload) });
                showAnimatedConfirmation('Feedback enviado com sucesso!', 'success');
                setTimeout(() => { feedbackModal.classList.remove('visible'); feedbackDescriptionTextarea.value = ''; clearStatusMessage(feedbackStatusDiv); }, 2000);
            } catch (error) {
                showAnimatedConfirmation('Falha ao enviar feedback.', 'error');
            } finally {
                submitFeedbackBtn.disabled = false;
                submitFeedbackBtn.innerHTML = 'Enviar';
            }
        }

        // --- Funções da Câmera e Upload ---

        /**
         * Abre a câmera e inicia a transmissão para o elemento de vídeo.
         * @param {string} facingMode - 'user' para câmera frontal, 'environment' para câmera traseira.
         */
        function openCamera(facingMode) {
            console.log("Tentando abrir a câmera...");
            const constraints = {
                video: {
                    facingMode: facingMode,
                    width: { ideal: 640 },  // Resolução ideal para captura
                    height: { ideal: 480 }
                },
                audio: false
            };
            
            // Garante que o contêiner da câmera esteja visível
            cameraContainer.style.display = 'block';

            // Obtém o stream da câmera
            navigator.mediaDevices.getUserMedia(constraints)
                .then(function(s) {
                    cameraStream = s;
                    cameraPreview.srcObject = cameraStream;
                    cameraPreview.play();
                    console.log("Câmera aberta com sucesso e stream iniciado.");
                })
                .catch(function(err) {
                    console.error("Erro ao acessar a câmera: ", err);
                    let errorMessage = "Não foi possível acessar a câmera.";

                    if (err.name === "NotAllowedError") {
                        errorMessage += " Permissão negada. Certifique-se de que o navegador e o sistema operacional permitem o acesso à câmera.";
                    } else if (err.name === "NotFoundError") {
                        errorMessage += " Nenhuma câmera encontrada ou conectada.";
                    } else if (err.name === "NotReadableError") {
                        errorMessage += " A câmera está sendo usada por outro aplicativo ou está indisponível.";
                    } else if (err.name === "OverconstrainedError") {
                        errorMessage += " As configurações da câmera solicitadas não são suportadas pelo seu dispositivo.";
                    } else if (err.name === "AbortError") {
                        errorMessage += " A operação da câmera foi abortada.";
                    } else if (err.name === "SecurityError") {
                        errorMessage += " O acesso à câmera foi bloqueado por questões de segurança (ex: site não é HTTPS).";
                    } else {
                        errorMessage += " Erro desconhecido: " + err.message;
                    }
                    
                    showAnimatedConfirmation(errorMessage, 'error');
                    closeCamera(); // Fecha a câmera se houver erro
                });
        }

        /**
         * Para o stream da câmera e esconde o contêiner da câmera.
         */
        function closeCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            cameraContainer.style.display = 'none'; // Garante que o contêiner esteja oculto
            cameraPreview.srcObject = null;
            console.log("Câmera fechada.");
        }

        /**
         * Captura uma foto do stream da câmera e a adiciona à lista de upload.
         */
        function capturePhoto() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Ajusta as proporções para a visualização
            canvas.width = cameraPreview.videoWidth;
            canvas.height = cameraPreview.videoHeight;
            context.drawImage(cameraPreview, 0, 0, canvas.width, canvas.height);
            
            // Converte para blob e cria um objeto File
            canvas.toBlob(function(blob) {
                const fileName = 'foto_' + new Date().getTime() + '.jpg';
                const file = new File([blob], fileName, {
                    type: 'image/jpeg',
                    lastModified: Date.now()
                });
                
                // Adiciona à lista de upload
                addFileToUpload(file);
                
                // Fecha a câmera após a captura
                closeCamera();
                showAnimatedConfirmation("Foto capturada com sucesso!", 'success');
            }, 'image/jpeg', 0.85);  // Qualidade da imagem
        }

        /**
         * Adiciona um arquivo à lista de arquivos para upload e atualiza as miniaturas.
         * @param {File} file - O objeto File a ser adicionado.
         */
        function addFileToUpload(file) {
            filesToUpload.push(file);
            updateThumbnails();
            
            // Remove a classe 'no-photos' se for a primeira adição
            if (thumbnailsContainer.classList.contains('no-photos')) {
                thumbnailsContainer.classList.remove('no-photos');
                thumbnailsContainer.innerHTML = '';
            }
            console.log(`Foto "${file.name}" adicionada. Total: ${filesToUpload.length}`);
        }

        /**
         * Remove um arquivo da lista de upload pelo índice e atualiza as miniaturas.
         * @param {number} index - O índice do arquivo a ser removido.
         */
        function removeFile(index) {
            const removedFileName = filesToUpload[index].name;
            filesToUpload.splice(index, 1);
            updateThumbnails();
            
            // Mostra mensagem se não houver mais fotos
            if (filesToUpload.length === 0) {
                thumbnailsContainer.innerHTML = '<span class="no-photos text-slate-500 italic">Nenhuma foto selecionada ainda</span>';
                thumbnailsContainer.classList.add('no-photos');
            }
            console.log(`Foto "${removedFileName}" removida. Restantes: ${filesToUpload.length}`);
        }

        /**
         * Atualiza a área de exibição de miniaturas com base no array `filesToUpload`.
         */
        function updateThumbnails() {
            // Limpa as miniaturas existentes, mas preserva a mensagem "no-photos" se aplicável
            if (!thumbnailsContainer.classList.contains('no-photos')) {
                thumbnailsContainer.innerHTML = '';
            } else {
                thumbnailsContainer.innerHTML = '<span class="no-photos text-slate-500 italic">Nenhuma foto selecionada ainda</span>';
            }
            
            // Cria as miniaturas apenas se houver arquivos
            if (filesToUpload.length > 0) {
                thumbnailsContainer.classList.remove('no-photos'); // Remove a classe se tiver fotos
                thumbnailsContainer.innerHTML = ''; // Limpa antes de adicionar novas miniaturas
                filesToUpload.forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const thumbnailDiv = document.createElement('div');
                        thumbnailDiv.className = 'thumbnail';
                        
                        thumbnailDiv.innerHTML = `
                            <img src="${e.target.result}" alt="${file.name}">
                            <button class="remove-btn" onclick="removeFile(${index})" title="Remover foto">×</button>
                        `;
                        
                        thumbnailsContainer.appendChild(thumbnailDiv);
                    };
                    reader.readAsDataURL(file);
                });
            }
        }

        /**
         * Envia todas as fotos selecionadas para o Google Drive através de um Google Apps Script separado.
         * Retorna true se todos os uploads foram bem-sucedidos, false caso contrário.
         */
        async function uploadPhotos() { 
            if (filesToUpload.length === 0) {
                console.log("Nenhuma foto para upload.");
                return true; // Considera sucesso se não houver fotos para enviar
            }

            if (!currentTestId) {
                // Não mostra confirmação animada aqui, pois a principal tratará o caso.
                console.error("Erro: Um ID de teste não foi gerado para associar as fotos.");
                return false; // Falha se não há ID para associar as fotos
            }

            // O nome do cliente é usado no filename, certifique-se de que ele esteja preenchido
            const clienteNameForFilename = clienteInput.value.trim().replace(/[^a-zA-Z0-9_]/g, ''); 
            if (!clienteNameForFilename) {
                // Não mostra confirmação animada aqui, pois a principal tratará o caso.
                console.error("Erro: Nome do cliente não preenchido para nomear as fotos.");
                return false;
            }

            photoLoadingMessageDiv.style.display = 'block'; // Exibe a mensagem de carregamento para as fotos
            
            let allPhotosUploadedSuccessfully = true;
            let successfulUploadsCount = 0;
            let failedUploadsCount = 0;

            for (let i = 0; i < filesToUpload.length; i++) {
                const file = filesToUpload[i];
                console.log(`Iniciando upload de: ${file.name}`);

                const base64 = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = () => reject("Erro ao ler arquivo: " + file.name);
                    reader.readAsDataURL(file);
                });

                const formData = new FormData();
                formData.append("filedata", base64);
                // Pré-fixa o nome do arquivo com o ID do teste E o nome do cliente
                formData.append("filename", `${currentTestId}_${clienteNameForFilename}_${file.name}`); 
                formData.append("mimeType", file.type);
                
                try {
                    const response = await fetch(PHOTO_UPLOAD_SCRIPT_URL, {
                        method: "POST",
                        body: formData
                    });

                    const result = response.text(); 
                    if ((await result).includes("sucesso")) { 
                        successfulUploadsCount++;
                        console.log(`Upload de ${file.name} bem-sucedido.`);
                    } else {
                        allPhotosUploadedSuccessfully = false;
                        failedUploadsCount++;
                        console.error(`Erro ao enviar ${file.name}: ${await result}`); 
                    }
                } catch (error) {
                    allPhotosUploadedSuccessfully = false;
                    failedUploadsCount++;
                    console.error(`Erro na requisição de upload de ${file.name}: ${error.message}`);
                }
            }
            
            photoLoadingMessageDiv.style.display = 'none'; // Oculta a mensagem de carregamento

            // A confirmação animada para o upload das fotos não será exibida aqui separadamente.
            // A mensagem final do formulário principal será agregada.
            
            // Limpa após o envio das fotos
            filesToUpload = [];
            updateThumbnails(); 

            return allPhotosUploadedSuccessfully; // Retorna o status do upload das fotos
        }

        /**
         * Mostra uma mensagem de confirmação animada.
         * @param {string} message - A mensagem a ser exibida.
         * @param {'success'|'error'|'warning'} type - O tipo da mensagem (determina cor e ícone).
         */
        function showAnimatedConfirmation(message, type) {
            const iconSpan = animatedConfirmationDiv.querySelector('.icon');
            const messageP = animatedConfirmationDiv.querySelector('.message');

            // Limpa classes anteriores e define o tipo
            animatedConfirmationDiv.classList.remove('success', 'error', 'warning', 'is-animating');
            animatedConfirmationDiv.classList.add(type);

            // Define o ícone e a mensagem
            if (type === 'success') {
                iconSpan.innerHTML = '&#10003;'; // Símbolo de verificação
            } else if (type === 'error') {
                iconSpan.innerHTML = '&#10007;'; // Símbolo X
            } else if (type === 'warning') {
                iconSpan.innerHTML = '&#9888;'; // Símbolo de aviso
            }
            messageP.textContent = message;

            // Garante que o elemento está visível e opaco antes de adicionar a animação
            animatedConfirmationDiv.style.opacity = 1;
            animatedConfirmationDiv.style.visibility = 'visible';
            
            // Adiciona a classe que dispara a animação
            animatedConfirmationDiv.classList.add('is-animating');

            // Oculta o elemento após a duração da animação
            setTimeout(() => {
                animatedConfirmationDiv.classList.remove('is-animating'); // Remove a classe de animação
                animatedConfirmationDiv.style.opacity = 0;
                animatedConfirmationDiv.style.visibility = 'hidden';
            }, 3000); // Duração da animação
        }
        
        // --- INICIALIZAÇÃO E LISTENERS GLOBAIS ---
        mainLoginBtn.addEventListener('click', handleLogin);
        mainTesterNameInput.addEventListener('keypress', (e) => { if (e.key === "Enter") handleLogin(); });
        logoutBtn.addEventListener('click', handleLogout);
        
        backToMenuBtn.addEventListener('click', () => {
            window.close(); // Fecha a janela/aba atual
        });
        
        checkLoginStatus(); // Ponto de entrada da aplicação
        updateThumbnails(); // Inicializa a área de miniaturas com a mensagem padrão
    });
    </script>
</body>
</html>
